{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\bys\\\\Desktop\\\\000 \\uAE30\\uC5C5\\uD615\\uB808\\uC774\\uC544\\uC6C3 react\\\\src\\\\components\\\\common\\\\Layout.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Layout(props) {\n  return /*#__PURE__*/_jsxDEV(\"section\", {\n    className: `content ${porps.name}`,\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: props.name\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 4,\n      columnNumber: 4\n    }, this), props.children]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 3,\n    columnNumber: 3\n  }, this);\n}\n_c = Layout;\nexport default Layout;\n\n// function Layout(props) {\n// \treturn (\n// \t\t<section className={`content ${props.name}`}>\n// \t\t\t<figure></figure>\n// \t\t\t<div className='inner'>\n// \t\t\t\t<h1>{props.name}</h1>\n// \t\t\t\t{props.children}\n// \t\t\t</div>\n// \t\t</section>\n// \t);\n// }\n\n// export default Layout;\n\n/*\r\n먼저 리액트가 render할 때 코드가 어떻게 컴파일하는지 알면 이해할 수 있다\r\n\r\nReact.createElement(Component,props,...children)를 이용해서 반환한다\r\n\r\nprops는 객체형태로 children까지 전달한다\r\n여는태그와 닫는태그가 있는 JSX 표현에서 두 태그 사이의 내용은 props.children이라는 특수한 prop으로 넘겨집니다.(출처 리액트공식노트)\r\n\r\n어떤 컴포넌트들은 어떤 자식 element가 들어올지 예상이 안되는 경우가 비일비재하다\r\n이런 경우, 같은 레아이웃 안에 다른 내용을 보여줘야 할 경우\r\n(gallery의 경우 사진이, community의 경우 table 태그 등)\r\nchildren을 사용하면 효율적으로 Layout.js라는 컴포넌트를 재사용할 수 있다 → props.childre을 사용하는 이점\r\n*/\nvar _c;\n$RefreshReg$(_c, \"Layout\");","map":{"version":3,"names":["Layout","props","porps","name","children"],"sources":["C:/Users/bys/Desktop/000 기업형레이아웃 react/src/components/common/Layout.js"],"sourcesContent":["function Layout(props) {\r\n\treturn (\r\n\t\t<section className={`content ${porps.name}`}>\r\n\t\t\t<h2>{props.name}</h2>\r\n\t\t\t{props.children}\r\n\t\t</section>\r\n\t);\r\n}\r\n\r\nexport default Layout;\r\n\r\n// function Layout(props) {\r\n// \treturn (\r\n// \t\t<section className={`content ${props.name}`}>\r\n// \t\t\t<figure></figure>\r\n// \t\t\t<div className='inner'>\r\n// \t\t\t\t<h1>{props.name}</h1>\r\n// \t\t\t\t{props.children}\r\n// \t\t\t</div>\r\n// \t\t</section>\r\n// \t);\r\n// }\r\n\r\n// export default Layout;\r\n\r\n/*\r\n먼저 리액트가 render할 때 코드가 어떻게 컴파일하는지 알면 이해할 수 있다\r\n\r\nReact.createElement(Component,props,...children)를 이용해서 반환한다\r\n\r\nprops는 객체형태로 children까지 전달한다\r\n여는태그와 닫는태그가 있는 JSX 표현에서 두 태그 사이의 내용은 props.children이라는 특수한 prop으로 넘겨집니다.(출처 리액트공식노트)\r\n\r\n어떤 컴포넌트들은 어떤 자식 element가 들어올지 예상이 안되는 경우가 비일비재하다\r\n이런 경우, 같은 레아이웃 안에 다른 내용을 보여줘야 할 경우\r\n(gallery의 경우 사진이, community의 경우 table 태그 등)\r\nchildren을 사용하면 효율적으로 Layout.js라는 컴포넌트를 재사용할 수 있다 → props.childre을 사용하는 이점\r\n*/\r\n"],"mappings":";;AAAA,SAASA,MAAM,CAACC,KAAK,EAAE;EACtB,oBACC;IAAS,SAAS,EAAG,WAAUC,KAAK,CAACC,IAAK,EAAE;IAAA,wBAC3C;MAAA,UAAKF,KAAK,CAACE;IAAI;MAAA;MAAA;MAAA;IAAA,QAAM,EACpBF,KAAK,CAACG,QAAQ;EAAA;IAAA;IAAA;IAAA;EAAA,QACN;AAEZ;AAAC,KAPQJ,MAAM;AASf,eAAeA,MAAM;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}