{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\bys\\\\Desktop\\\\000 \\uAE30\\uC5C5\\uD615\\uB808\\uC774\\uC544\\uC6C3 react\\\\src\\\\components\\\\common\\\\Layout.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Layout(props) {\n  // props는 부모로부터 전달받은 인수값\n  return /*#__PURE__*/_jsxDEV(\"section\", {\n    className: `content ${props.name}`,\n    children: [/*#__PURE__*/_jsxDEV(\"figure\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 4\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"inner\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: props.name\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 5\n      }, this), props.children]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 4\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 4,\n    columnNumber: 3\n  }, this);\n}\n_c = Layout;\nexport default Layout;\n\n/*\r\n먼저 리액트가 render할 때 코드가 어떻게 컴파일하는지 알면 이해할 수 있다\r\n\r\nReact.createElement(Component,props,...children)를 이용해서 반환한다\r\n\r\nprops는 객체형태로 children까지 전달한다\r\n여는태그와 닫는태그가 있는 JSX 표현에서 두 태그 사이의 내용은 props.children이라는 특수한 prop으로 넘겨집니다.(출처 리액트공식노트)\r\n\r\n어떤 컴포넌트들은 어떤 자식 element가 들어올지 예상이 안되는 경우가 비일비재하다\r\n이런 경우, 같은 레아이웃 안에 다른 내용을 보여줘야 할 경우\r\n(gallery의 경우 사진이, community의 경우 table 태그 등)\r\nchildren을 사용하면 효율적으로 Layout.js라는 컴포넌트를 재사용할 수 있다 → props.childre을 사용하는 이점\r\n*/\nvar _c;\n$RefreshReg$(_c, \"Layout\");","map":{"version":3,"names":["Layout","props","name","children"],"sources":["C:/Users/bys/Desktop/000 기업형레이아웃 react/src/components/common/Layout.js"],"sourcesContent":["function Layout(props) {\r\n\t// props는 부모로부터 전달받은 인수값\r\n\treturn (\r\n\t\t<section className={`content ${props.name}`}>\r\n\t\t\t{/* class 이름이 2가지, 하나는 content공동 클래스,\r\n      다른 하나ㅡㄴ 부모 props로 받은 값을 전달해서 생성되는\r\n      서브클래스인데 공통클래스는 문자열, 서브클래스는 매개변수이기때문에 변수처리 ${}로 변수임을 알려야한다\r\n      그리고 변수와 문자열을 혼합해서 작성하기위해 백틱으로 감쌈 */}\r\n\t\t\t<figure></figure>\r\n\t\t\t<div className='inner'>\r\n\t\t\t\t<h1>{props.name}</h1>\r\n\t\t\t\t{/* props에서 넘기는 값을 그대로 사용해도 되는 값이기때문에\r\n        클래스에도 클래스에도 이곳에도 적용\r\n        문자열과 혼용하지않아 ${}없이 매개변수로 인식가능 */}\r\n\t\t\t\t{props.children}\r\n\t\t\t\t{/* 부모컴포넌트에서 <Layout></Layout>사이의 모든 내용들을 한번에 children으로 받아서 적용하는 것 */}\r\n\t\t\t</div>\r\n\t\t</section>\r\n\t);\r\n}\r\n\r\nexport default Layout;\r\n\r\n/*\r\n먼저 리액트가 render할 때 코드가 어떻게 컴파일하는지 알면 이해할 수 있다\r\n\r\nReact.createElement(Component,props,...children)를 이용해서 반환한다\r\n\r\nprops는 객체형태로 children까지 전달한다\r\n여는태그와 닫는태그가 있는 JSX 표현에서 두 태그 사이의 내용은 props.children이라는 특수한 prop으로 넘겨집니다.(출처 리액트공식노트)\r\n\r\n어떤 컴포넌트들은 어떤 자식 element가 들어올지 예상이 안되는 경우가 비일비재하다\r\n이런 경우, 같은 레아이웃 안에 다른 내용을 보여줘야 할 경우\r\n(gallery의 경우 사진이, community의 경우 table 태그 등)\r\nchildren을 사용하면 효율적으로 Layout.js라는 컴포넌트를 재사용할 수 있다 → props.childre을 사용하는 이점\r\n*/\r\n"],"mappings":";;AAAA,SAASA,MAAM,CAACC,KAAK,EAAE;EACtB;EACA,oBACC;IAAS,SAAS,EAAG,WAAUA,KAAK,CAACC,IAAK,EAAE;IAAA,wBAK3C;MAAA;MAAA;MAAA;IAAA,QAAiB,eACjB;MAAK,SAAS,EAAC,OAAO;MAAA,wBACrB;QAAA,UAAKD,KAAK,CAACC;MAAI;QAAA;QAAA;QAAA;MAAA,QAAM,EAIpBD,KAAK,CAACE,QAAQ;IAAA;MAAA;MAAA;MAAA;IAAA,QAEV;EAAA;IAAA;IAAA;IAAA;EAAA,QACG;AAEZ;AAAC,KAnBQH,MAAM;AAqBf,eAAeA,MAAM;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}